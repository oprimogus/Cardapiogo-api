// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStore = `-- name: CreateStore :exec
INSERT INTO store (id, cpf_cnpj, owner_id, name, active, phone, score, type, address_line_1, address_line_2, neighborhood, city, state, postal_code,
  latitude, longitude, country, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW() AT TIME ZONE 'UTC', NOW() AT TIME ZONE 'UTC')
`

type CreateStoreParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	CpfCnpj      string      `db:"cpf_cnpj" json:"cpf_cnpj"`
	OwnerID      pgtype.UUID `db:"owner_id" json:"owner_id"`
	Name         string      `db:"name" json:"name"`
	Active       bool        `db:"active" json:"active"`
	Phone        string      `db:"phone" json:"phone"`
	Score        int32       `db:"score" json:"score"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	PostalCode   string      `db:"postal_code" json:"postal_code"`
	Latitude     pgtype.Text `db:"latitude" json:"latitude"`
	Longitude    pgtype.Text `db:"longitude" json:"longitude"`
	Country      string      `db:"country" json:"country"`
}

// CreateStore
//
//	INSERT INTO store (id, cpf_cnpj, owner_id, name, active, phone, score, type, address_line_1, address_line_2, neighborhood, city, state, postal_code,
//	  latitude, longitude, country, created_at, updated_at)
//	VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW() AT TIME ZONE 'UTC', NOW() AT TIME ZONE 'UTC')
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) error {
	_, err := q.db.Exec(ctx, createStore,
		arg.ID,
		arg.CpfCnpj,
		arg.OwnerID,
		arg.Name,
		arg.Active,
		arg.Phone,
		arg.Score,
		arg.Type,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Neighborhood,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Latitude,
		arg.Longitude,
		arg.Country,
	)
	return err
}

const findStoreBusinessHoursByStoreId = `-- name: FindStoreBusinessHoursByStoreId :many
SELECT bh.store_id, bh.week_day, bh.opening_time, bh.closing_time, bh.timezone
FROM business_hour bh
WHERE 1 = 1
  AND bh.store_id = ANY($1::UUID[])
`

// FindStoreBusinessHoursByStoreId
//
//	SELECT bh.store_id, bh.week_day, bh.opening_time, bh.closing_time, bh.timezone
//	FROM business_hour bh
//	WHERE 1 = 1
//	  AND bh.store_id = ANY($1::UUID[])
func (q *Queries) FindStoreBusinessHoursByStoreId(ctx context.Context, dollar_1 []pgtype.UUID) ([]BusinessHour, error) {
	rows, err := q.db.Query(ctx, findStoreBusinessHoursByStoreId, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BusinessHour
	for rows.Next() {
		var i BusinessHour
		if err := rows.Scan(
			&i.StoreID,
			&i.WeekDay,
			&i.OpeningTime,
			&i.ClosingTime,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreBusinessHoursByID = `-- name: GetStoreBusinessHoursByID :many
SELECT week_day, timezone, opening_time, closing_time
FROM business_hour
WHERE store_id = $1
ORDER BY week_day
`

type GetStoreBusinessHoursByIDRow struct {
	WeekDay     int32       `db:"week_day" json:"week_day"`
	Timezone    string      `db:"timezone" json:"timezone"`
	OpeningTime pgtype.Time `db:"opening_time" json:"opening_time"`
	ClosingTime pgtype.Time `db:"closing_time" json:"closing_time"`
}

// GetStoreBusinessHoursByID
//
//	SELECT week_day, timezone, opening_time, closing_time
//	FROM business_hour
//	WHERE store_id = $1
//	ORDER BY week_day
func (q *Queries) GetStoreBusinessHoursByID(ctx context.Context, storeID pgtype.UUID) ([]GetStoreBusinessHoursByIDRow, error) {
	rows, err := q.db.Query(ctx, getStoreBusinessHoursByID, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoreBusinessHoursByIDRow
	for rows.Next() {
		var i GetStoreBusinessHoursByIDRow
		if err := rows.Scan(
			&i.WeekDay,
			&i.Timezone,
			&i.OpeningTime,
			&i.ClosingTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByFilter = `-- name: GetStoreByFilter :many
SELECT s.id, s.name, s.score, s.type, s.neighborhood, s.latitude, s.longitude, s.profile_image
FROM store s
WHERE 1 = 1
  AND (COALESCE(NULLIF($1, ''), s.name) IS NULL OR s.name LIKE '%' || COALESCE(NULLIF($1, ''), s.name) || '%')
  AND (COALESCE($2, s.score) IS NULL OR s.score >= COALESCE($2, s.score))
  AND (COALESCE(NULLIF($3, '')::"ShopType", s.type) IS NULL OR s.type = COALESCE(NULLIF($3, '')::"ShopType", s.type))
  AND (COALESCE(NULLIF($4, ''), s.city) IS NULL OR s.city = COALESCE(NULLIF($4, ''), s.city))
ORDER BY s.score DESC, s.type
`

type GetStoreByFilterParams struct {
	Column1 interface{} `db:"column_1" json:"column_1"`
	Column2 interface{} `db:"column_2" json:"column_2"`
	Column3 interface{} `db:"column_3" json:"column_3"`
	Column4 interface{} `db:"column_4" json:"column_4"`
}

type GetStoreByFilterRow struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	Name         string      `db:"name" json:"name"`
	Score        int32       `db:"score" json:"score"`
	Type         ShopType    `db:"type" json:"type"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	Latitude     pgtype.Text `db:"latitude" json:"latitude"`
	Longitude    pgtype.Text `db:"longitude" json:"longitude"`
	ProfileImage pgtype.Text `db:"profile_image" json:"profile_image"`
}

// GetStoreByFilter
//
//	SELECT s.id, s.name, s.score, s.type, s.neighborhood, s.latitude, s.longitude, s.profile_image
//	FROM store s
//	WHERE 1 = 1
//	  AND (COALESCE(NULLIF($1, ''), s.name) IS NULL OR s.name LIKE '%' || COALESCE(NULLIF($1, ''), s.name) || '%')
//	  AND (COALESCE($2, s.score) IS NULL OR s.score >= COALESCE($2, s.score))
//	  AND (COALESCE(NULLIF($3, '')::"ShopType", s.type) IS NULL OR s.type = COALESCE(NULLIF($3, '')::"ShopType", s.type))
//	  AND (COALESCE(NULLIF($4, ''), s.city) IS NULL OR s.city = COALESCE(NULLIF($4, ''), s.city))
//	ORDER BY s.score DESC, s.type
func (q *Queries) GetStoreByFilter(ctx context.Context, arg GetStoreByFilterParams) ([]GetStoreByFilterRow, error) {
	rows, err := q.db.Query(ctx, getStoreByFilter,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoreByFilterRow
	for rows.Next() {
		var i GetStoreByFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Type,
			&i.Neighborhood,
			&i.Latitude,
			&i.Longitude,
			&i.ProfileImage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT s.id, s.name, s.phone, s.score, s.type, s.address_line_1, 
s.address_line_2, s.neighborhood, s.city, s.state, s.country, s.profile_image, s.header_image
FROM store s
WHERE id = $1
`

type GetStoreByIDRow struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	Name         string      `db:"name" json:"name"`
	Phone        string      `db:"phone" json:"phone"`
	Score        int32       `db:"score" json:"score"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	Country      string      `db:"country" json:"country"`
	ProfileImage pgtype.Text `db:"profile_image" json:"profile_image"`
	HeaderImage  pgtype.Text `db:"header_image" json:"header_image"`
}

// GetStoreByID
//
//	SELECT s.id, s.name, s.phone, s.score, s.type, s.address_line_1,
//	s.address_line_2, s.neighborhood, s.city, s.state, s.country, s.profile_image, s.header_image
//	FROM store s
//	WHERE id = $1
func (q *Queries) GetStoreByID(ctx context.Context, id pgtype.UUID) (GetStoreByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreByID, id)
	var i GetStoreByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Score,
		&i.Type,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Neighborhood,
		&i.City,
		&i.State,
		&i.Country,
		&i.ProfileImage,
		&i.HeaderImage,
	)
	return i, err
}

const isOwner = `-- name: IsOwner :one
SELECT EXISTS(SELECT 1 FROM store WHERE id = $1 AND owner_id = $2)
`

type IsOwnerParams struct {
	ID      pgtype.UUID `db:"id" json:"id"`
	OwnerID pgtype.UUID `db:"owner_id" json:"owner_id"`
}

// IsOwner
//
//	SELECT EXISTS(SELECT 1 FROM store WHERE id = $1 AND owner_id = $2)
func (q *Queries) IsOwner(ctx context.Context, arg IsOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOwner, arg.ID, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const setHeaderImage = `-- name: SetHeaderImage :exec
UPDATE store
  SET 
    header_image = $2
WHERE id = $1
`

type SetHeaderImageParams struct {
	ID          pgtype.UUID `db:"id" json:"id"`
	HeaderImage pgtype.Text `db:"header_image" json:"header_image"`
}

// SetHeaderImage
//
//	UPDATE store
//	  SET
//	    header_image = $2
//	WHERE id = $1
func (q *Queries) SetHeaderImage(ctx context.Context, arg SetHeaderImageParams) error {
	_, err := q.db.Exec(ctx, setHeaderImage, arg.ID, arg.HeaderImage)
	return err
}

const setProfileImage = `-- name: SetProfileImage :exec
UPDATE store
  SET 
    profile_image = $2
WHERE id = $1
`

type SetProfileImageParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	ProfileImage pgtype.Text `db:"profile_image" json:"profile_image"`
}

// SetProfileImage
//
//	UPDATE store
//	  SET
//	    profile_image = $2
//	WHERE id = $1
func (q *Queries) SetProfileImage(ctx context.Context, arg SetProfileImageParams) error {
	_, err := q.db.Exec(ctx, setProfileImage, arg.ID, arg.ProfileImage)
	return err
}

const updateStore = `-- name: UpdateStore :exec
UPDATE store
  SET 
    name = $3,
    phone = $4,
    type = $5,
    address_line_1 = $6,
    address_line_2 = $7,
    neighborhood = $8,
    city = $9,
    state = $10,
    postal_code = $11,
    country = $12,
    updated_at = NOW() AT TIME ZONE 'UTC'
WHERE id = $1 AND owner_id = $2
`

type UpdateStoreParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	OwnerID      pgtype.UUID `db:"owner_id" json:"owner_id"`
	Name         string      `db:"name" json:"name"`
	Phone        string      `db:"phone" json:"phone"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	PostalCode   string      `db:"postal_code" json:"postal_code"`
	Country      string      `db:"country" json:"country"`
}

// UpdateStore
//
//	UPDATE store
//	  SET
//	    name = $3,
//	    phone = $4,
//	    type = $5,
//	    address_line_1 = $6,
//	    address_line_2 = $7,
//	    neighborhood = $8,
//	    city = $9,
//	    state = $10,
//	    postal_code = $11,
//	    country = $12,
//	    updated_at = NOW() AT TIME ZONE 'UTC'
//	WHERE id = $1 AND owner_id = $2
func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) error {
	_, err := q.db.Exec(ctx, updateStore,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Phone,
		arg.Type,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Neighborhood,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
	)
	return err
}
