// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createStore = `-- name: CreateStore :exec
INSERT INTO store (id, cpf_cnpj, owner_id, name, active, phone, score, type, address_line_1, address_line_2, neighborhood, city, state, postal_code,
  latitude, longitude, country, created_at, updated_at)
VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW(), NOW())
`

type CreateStoreParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	CpfCnpj      string      `db:"cpf_cnpj" json:"cpf_cnpj"`
	OwnerID      pgtype.UUID `db:"owner_id" json:"owner_id"`
	Name         string      `db:"name" json:"name"`
	Active       bool        `db:"active" json:"active"`
	Phone        string      `db:"phone" json:"phone"`
	Score        int32       `db:"score" json:"score"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	PostalCode   string      `db:"postal_code" json:"postal_code"`
	Latitude     pgtype.Text `db:"latitude" json:"latitude"`
	Longitude    pgtype.Text `db:"longitude" json:"longitude"`
	Country      string      `db:"country" json:"country"`
}

// CreateStore
//
//	INSERT INTO store (id, cpf_cnpj, owner_id, name, active, phone, score, type, address_line_1, address_line_2, neighborhood, city, state, postal_code,
//	  latitude, longitude, country, created_at, updated_at)
//	VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, NOW(), NOW())
func (q *Queries) CreateStore(ctx context.Context, arg CreateStoreParams) error {
	_, err := q.db.Exec(ctx, createStore,
		arg.ID,
		arg.CpfCnpj,
		arg.OwnerID,
		arg.Name,
		arg.Active,
		arg.Phone,
		arg.Score,
		arg.Type,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Neighborhood,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Latitude,
		arg.Longitude,
		arg.Country,
	)
	return err
}

const getStoreBusinessHoursByID = `-- name: GetStoreBusinessHoursByID :many
SELECT week_day, opening_time, closing_time
FROM business_hour
WHERE store_id = $1
ORDER BY week_day
`

type GetStoreBusinessHoursByIDRow struct {
	WeekDay     int32  `db:"week_day" json:"week_day"`
	OpeningTime string `db:"opening_time" json:"opening_time"`
	ClosingTime string `db:"closing_time" json:"closing_time"`
}

// GetStoreBusinessHoursByID
//
//	SELECT week_day, opening_time, closing_time
//	FROM business_hour
//	WHERE store_id = $1
//	ORDER BY week_day
func (q *Queries) GetStoreBusinessHoursByID(ctx context.Context, storeID pgtype.UUID) ([]GetStoreBusinessHoursByIDRow, error) {
	rows, err := q.db.Query(ctx, getStoreBusinessHoursByID, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStoreBusinessHoursByIDRow
	for rows.Next() {
		var i GetStoreBusinessHoursByIDRow
		if err := rows.Scan(&i.WeekDay, &i.OpeningTime, &i.ClosingTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByID = `-- name: GetStoreByID :one
SELECT s.id, s.name, s.phone, s.score, s.type, s.address_line_1, s.address_line_2, s.neighborhood, s.city, s.state, s.country
FROM store s
WHERE id = $1
`

type GetStoreByIDRow struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	Name         string      `db:"name" json:"name"`
	Phone        string      `db:"phone" json:"phone"`
	Score        int32       `db:"score" json:"score"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	Country      string      `db:"country" json:"country"`
}

// GetStoreByID
//
//	SELECT s.id, s.name, s.phone, s.score, s.type, s.address_line_1, s.address_line_2, s.neighborhood, s.city, s.state, s.country
//	FROM store s
//	WHERE id = $1
func (q *Queries) GetStoreByID(ctx context.Context, id pgtype.UUID) (GetStoreByIDRow, error) {
	row := q.db.QueryRow(ctx, getStoreByID, id)
	var i GetStoreByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Phone,
		&i.Score,
		&i.Type,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.Neighborhood,
		&i.City,
		&i.State,
		&i.Country,
	)
	return i, err
}

const isOwner = `-- name: IsOwner :one
SELECT EXISTS(SELECT 1 FROM store WHERE id = $1 AND owner_id = $2)
`

type IsOwnerParams struct {
	ID      pgtype.UUID `db:"id" json:"id"`
	OwnerID pgtype.UUID `db:"owner_id" json:"owner_id"`
}

// IsOwner
//
//	SELECT EXISTS(SELECT 1 FROM store WHERE id = $1 AND owner_id = $2)
func (q *Queries) IsOwner(ctx context.Context, arg IsOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOwner, arg.ID, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateStore = `-- name: UpdateStore :exec
UPDATE store
  SET 
    name = $3,
    phone = $4,
    type = $5,
    address_line_1 = $6,
    address_line_2 = $7,
    neighborhood = $8,
    city = $9,
    state = $10,
    postal_code = $11,
    country = $12,
    updated_at = NOW()
WHERE id = $1 AND owner_id = $2
`

type UpdateStoreParams struct {
	ID           pgtype.UUID `db:"id" json:"id"`
	OwnerID      pgtype.UUID `db:"owner_id" json:"owner_id"`
	Name         string      `db:"name" json:"name"`
	Phone        string      `db:"phone" json:"phone"`
	Type         ShopType    `db:"type" json:"type"`
	AddressLine1 string      `db:"address_line_1" json:"address_line_1"`
	AddressLine2 string      `db:"address_line_2" json:"address_line_2"`
	Neighborhood string      `db:"neighborhood" json:"neighborhood"`
	City         string      `db:"city" json:"city"`
	State        string      `db:"state" json:"state"`
	PostalCode   string      `db:"postal_code" json:"postal_code"`
	Country      string      `db:"country" json:"country"`
}

// UpdateStore
//
//	UPDATE store
//	  SET
//	    name = $3,
//	    phone = $4,
//	    type = $5,
//	    address_line_1 = $6,
//	    address_line_2 = $7,
//	    neighborhood = $8,
//	    city = $9,
//	    state = $10,
//	    postal_code = $11,
//	    country = $12,
//	    updated_at = NOW()
//	WHERE id = $1 AND owner_id = $2
func (q *Queries) UpdateStore(ctx context.Context, arg UpdateStoreParams) error {
	_, err := q.db.Exec(ctx, updateStore,
		arg.ID,
		arg.OwnerID,
		arg.Name,
		arg.Phone,
		arg.Type,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.Neighborhood,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
	)
	return err
}
